"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sqlite3 = require("../sqlite3.pure");
const util_1 = require("./util");
const bindings = require("./bindings");
const DEFAULT_MODE = sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE;
const registry = new FinalizationRegistry((heldValue) => {
    if (heldValue.value == null) {
        return;
    }
    try {
        bindings.sqlite3_close(heldValue.value);
    }
    catch (_a) {
        // ignore
    }
});
class Database {
    constructor(file, mode, callback) {
        this.open = false;
        this._handle = { value: undefined };
        this._tasks = new Set();
        this._waitCallbacks = [];
        const dbMode = typeof mode === 'number' ? mode : DEFAULT_MODE;
        const defaultCallback = (err) => {
            if (err != null) {
                this.emit('error', err);
            }
            else {
                this.emit('open');
            }
        };
        const dbCallback = callback || (typeof mode === 'function' ? mode : defaultCallback);
        (0, util_1.tick)(() => {
            try {
                this._handle.value = bindings.sqlite3_open_v2(file, dbMode);
            }
            catch (error) {
                dbCallback(error);
                return;
            }
            registry.register(this, this._handle);
            this.open = true;
            dbCallback(null);
        });
    }
    close(callback) {
        const defaultCallback = (err) => {
            if (err != null) {
                this.emit('error', err);
            }
            else {
                this.emit('close');
            }
        };
        const closeCallback = callback || defaultCallback;
        (0, util_1.tick)(() => {
            const handle = this._handle.value;
            if (handle === undefined) {
                closeCallback(sqlite3.sqliteError('SQLITE_MISUSE', 'Database handle is closed', sqlite3.MISUSE));
                return;
            }
            try {
                bindings.sqlite3_close(handle);
            }
            catch (error) {
                closeCallback(error);
                return;
            }
            this.open = false;
            this._handle.value = undefined;
            closeCallback(null);
        });
    }
    configure() {
        // FIXME
    }
    exec(sql, callback) {
        (0, util_1.tick)(() => {
            const handle = this._handle.value;
            if (handle == null) {
                callback && callback(new Error('Database handle is closed'));
                return;
            }
            try {
                bindings.sqlite3_exec(handle, sql);
            }
            catch (error) {
                callback && callback(error);
                return;
            }
            callback && callback(null);
        });
        return this;
    }
    /*
     * This undocumented (sigh) method should invoke a callback once all "ongoing" stuff
     * for this database has finished. This implementation is most likely not correct, since not all
     * operations in a statement notify the _waitCallbacks "queue", but it is enough to pass tests.
     */
    wait(cb) {
        if (cb == null) {
            return;
        }
        if (cb != null && this._tasks.size > 0) {
            this._waitCallbacks.push(cb);
        }
        else {
            process.nextTick(cb);
        }
    }
    serialize(callback) {
        (0, util_1.tick)(() => callback && callback(null));
    }
    // for internal usage within the package
    _getHandle() {
        var _a;
        return (_a = this._handle) === null || _a === void 0 ? void 0 : _a.value;
    }
    // for internal usage within the package
    _addTask() {
        const taskId = {};
        this._tasks.add(taskId);
        return () => this._removeTask(taskId);
    }
    _removeTask(taskId) {
        const removed = this._tasks.delete(taskId);
        if (removed && this._tasks.size === 0) {
            this._waitCallbacks.forEach((cb) => process.nextTick(cb));
            this._waitCallbacks = [];
        }
    }
}
exports.default = Database;
