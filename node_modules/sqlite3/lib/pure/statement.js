"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sqlite3 = require("../sqlite3.pure");
const bindings = require("./bindings");
const util_1 = require("./util");
const NOOP = () => {
    /* NOOP */
};
const registry = new FinalizationRegistry((heldValue) => {
    const handle = heldValue.handle;
    if (handle == null) {
        return;
    }
    bindings.sqlite3_finalize_silent(handle);
});
class Statement {
    constructor(db, sql, errBack) {
        this._state = {
            status: 'new',
        };
        this._bound = false;
        this._queue = (0, util_1.queue)();
        this._gcHandle = { handle: undefined };
        this.sql = sql;
        this._db = db;
        (0, util_1.tick)(() => {
            // TODO: handle `db._handle() == null`
            let thrown;
            let handle = undefined;
            try {
                handle = bindings.sqlite3_prepare_v2(db._getHandle(), sql);
                this._state = { status: 'init', handle, done: false };
            }
            catch (error) {
                thrown = { error };
                this._state = { status: 'new' };
            }
            this._gcHandle = { handle };
            registry.register(this, this._gcHandle);
            if (errBack && (thrown === null || thrown === void 0 ? void 0 : thrown.error)) {
                errBack(thrown.error);
            }
        });
    }
    bind(...params) {
        const callback = typeof (0, util_1.last)(params) === 'function' ? params.pop() : NOOP;
        this._tick(callback, () => {
            this._bind(params);
            callback(null);
        });
        return this;
    }
    _bind(params) {
        return this._doBind(parseParams(params));
    }
    _doBind({ params, isMap }) {
        const handle = this._getHandle();
        const dbHandle = this._db._getHandle();
        if (dbHandle == null) {
            /*
             * This should not happen, since the statement already exists and
             * the db cannot be closed
             */
            throw new Error('Unexpected invalid database');
        }
        if (this._bound && params.length > 0) {
            bindings.sqlite3_clear_bindings(handle);
            this._bound = false;
        }
        for (const [name, value] of params) {
            const asNumber = parseInt(name, 10);
            let index;
            if (Number.isNaN(asNumber)) {
                index = bindings.sqlite3_bind_parameter_index(handle, name);
                if (index === 0) {
                    throw new TypeError(`Invalid parameter ${name}`);
                }
            }
            else {
                index = asNumber + (isMap ? 0 : 1);
            }
            let doBindParameter;
            if (typeof value === 'number' && Number.isSafeInteger(value)) {
                /**
                 * TODO: int64
                 * ints are tricky because, internally, all SQLite integers are 64 bits, and OTOH
                 * WASM can't really do i64 without involving BigInt's, which is a PITA.
                 *
                 * For now, we'll just settle for passing and receiving doubles everywhere.
                 */
                doBindParameter = () => bindings.sqlite3_bind_double(handle, dbHandle, index, value);
            }
            else if (typeof value === 'number') {
                doBindParameter = () => bindings.sqlite3_bind_double(handle, dbHandle, index, value);
            }
            else if (typeof value === 'boolean') {
                doBindParameter = () => bindings.sqlite3_bind_int(handle, dbHandle, index, value ? 1 : 0);
            }
            else if (value === null) {
                doBindParameter = () => bindings.sqlite3_bind_null(handle, dbHandle, index);
            }
            else if (typeof value === 'string') {
                doBindParameter = () => bindings.sqlite3_bind_text(handle, dbHandle, index, value);
            }
            else if (value instanceof Date) {
                doBindParameter = () => bindings.sqlite3_bind_double(handle, dbHandle, index, value.valueOf());
            }
            else if (value instanceof RegExp) {
                doBindParameter = () => bindings.sqlite3_bind_text(handle, dbHandle, index, value.toString());
            }
            else {
                throw new Error('Unimplemented');
            }
            doBindParameter();
            this._bound = true;
        }
    }
    reset(callback) {
        this._tick(callback || NOOP, () => {
            const state = this._getState();
            if (state == null) {
                callback && callback(null);
                return;
            }
            try {
                // TODO: handle db gone
                bindings.sqlite3_reset(state.handle, this._db._getHandle());
            }
            catch (_a) {
                // TODO: swallow error? API docs say this never fails...
            }
            state.done = false;
            callback && callback(null);
        });
        return this;
    }
    finalize(callback) {
        this._queue.onDone(() => {
            let handle;
            try {
                handle = this._getHandle();
            }
            catch (_a) {
                // Do nothing
                return;
            }
            // TODO: handle DB
            bindings.sqlite3_finalize(handle, this._db._getHandle());
            delete this._gcHandle.handle;
            this._state = { status: 'finalized' };
            callback && callback(null);
        });
    }
    run(...params) {
        const noopWithThis = function () {
            /* NOOP */
        };
        const callback = typeof (0, util_1.last)(params) === 'function' ? params.pop() : noopWithThis;
        this._tick((error) => callback.call(this, error), () => {
            const state = this._getState();
            bindings.sqlite3_reset(state.handle, this._db._getHandle());
            state.done = false;
            this._bind(params);
            this._tryStep();
            this.lastID = bindings.sqlite3_last_insert_rowid(this._db._getHandle());
            this.changes = bindings.sqlite3_changes(this._db._getHandle());
            callback.call(this, null);
        });
        return this;
    }
    get(...params) {
        const callback = typeof (0, util_1.last)(params) === 'function' ? params.pop() : NOOP;
        this._tick(callback, () => {
            const state = this._getState();
            const parsed = parseParams(params);
            if (parsed.params.length > 0) {
                bindings.sqlite3_reset(state.handle, this._db._getHandle());
                state.done = false;
            }
            this._doBind(parsed);
            const hasRow = this._tryStep();
            if (!hasRow) {
                callback(null);
                return;
            }
            const row = readRow(state.handle);
            callback(null, row);
        });
        return this;
    }
    all(...params) {
        const callback = typeof (0, util_1.last)(params) === 'function' ? params.pop() : NOOP;
        this._tick(callback, () => {
            const state = this._getState();
            bindings.sqlite3_reset(state.handle, this._db._getHandle());
            state.done = false;
            this._bind(params);
            const rows = [];
            while (this._tryStep()) {
                const row = readRow(state.handle);
                rows.push(row);
            }
            callback(null, rows);
        });
        return this;
    }
    each(...params) {
        const lastItem = (0, util_1.last)(params);
        const nextToLast = params[params.length - 2];
        let originalCallback = NOOP;
        let originalComplete = NOOP;
        if (typeof lastItem === 'function' && typeof nextToLast === 'function') {
            originalComplete = params.pop();
            originalCallback = params.pop();
        }
        else if (typeof lastItem === 'function') {
            originalCallback = params.pop();
        }
        const complete = (error, rows) => {
            if (error != null && error.ignore) {
                return;
            }
            originalComplete(error, rows);
        };
        const callback = (error, row) => {
            if (error != null && error.ignore) {
                return;
            }
            originalCallback(error, row);
        };
        let rows = 0;
        this._push(() => {
            let state;
            try {
                state = this._getState();
            }
            catch (error) {
                complete(error);
                return;
            }
            try {
                // TODO: only here? always?
                bindings.sqlite3_reset(state.handle, this._db._getHandle());
                state.done = false;
            }
            catch (error) {
                complete(error);
                return;
            }
            try {
                this._bind(params);
            }
            catch (error) {
                complete(error);
                return;
            }
            fetchRow();
        });
        const fetchRow = () => {
            const onError = rows > 0 ? callback : complete;
            let handle;
            try {
                handle = this._getHandle();
            }
            catch (error) {
                onError(error);
                return;
            }
            let hasRow;
            try {
                hasRow = this._tryStep();
            }
            catch (error) {
                onError(error);
                return;
            }
            if (!hasRow) {
                complete(null, rows);
                return;
            }
            const row = readRow(handle);
            rows++;
            this._push(fetchRow);
            callback(null, row);
        };
        return this;
    }
    _getHandle() {
        var _a;
        return (_a = this._getState()) === null || _a === void 0 ? void 0 : _a.handle;
    }
    _getState() {
        if (this._state.status === 'init') {
            return this._state;
        }
        else if (this._state.status === 'new') {
            /*
             * The only way to get here is if preparation failed, which should ignore any further
             * operations.
             */
            const error = new Error('Preparation failed');
            error.ignore = true;
            throw error;
        }
        else {
            throw sqlite3.sqliteError('SQLITE_MISUSE', 'Statement is already finalized', sqlite3.MISUSE);
        }
    }
    _tryStep() {
        const state = this._getState();
        if (state.done) {
            return false;
        }
        const hasRows = bindings.sqlite3_step(state.handle, this._db._getHandle());
        state.done = state.done || !hasRows;
        return hasRows;
    }
    _tick(callback, task) {
        (0, util_1.tick)(() => {
            try {
                task();
            }
            catch (error) {
                if (error != null && error.ignore) {
                    return;
                }
                callback(error);
            }
        });
    }
    _push(task) {
        const taskDone = this._db._addTask();
        this._queue.push(() => {
            try {
                task();
            }
            finally {
                taskDone();
            }
        });
    }
}
exports.default = Statement;
function parseParams(params) {
    let bindParams;
    let isMap = false;
    if (params.length !== 1) {
        bindParams = Object.entries(params);
    }
    else if (Array.isArray(params[0])) {
        bindParams = Object.entries(params[0]);
    }
    else if (params[0] == null) {
        bindParams = [];
    }
    else if (typeof params[0] === 'object' && !isValidParam(params[0])) {
        isMap = true;
        bindParams = Object.entries(params[0]);
    }
    else {
        bindParams = [['0', params[0]]];
    }
    return { params: bindParams, isMap };
}
function readRow(handle) {
    const row = {};
    const count = bindings.sqlite3_column_count(handle);
    for (let index = 0; index < count; index++) {
        const name = bindings.sqlite3_column_name(handle, index);
        const type = bindings.sqlite3_column_type(handle, index);
        let value;
        // TODO: blob
        switch (type) {
            case sqlite3.INTEGER: {
                // TODO: int64
                value = bindings.sqlite3_column_double(handle, index);
                break;
            }
            case sqlite3.TEXT: {
                value = bindings.sqlite3_column_text(handle, index);
                break;
            }
            case sqlite3.FLOAT: {
                value = bindings.sqlite3_column_double(handle, index);
                break;
            }
            case sqlite3.NULL: {
                value = null;
                break;
            }
            default: {
                throw new Error('Unexpected type: ' + type);
            }
        }
        row[name] = value;
    }
    return row;
}
function isValidParam(param) {
    return param instanceof Date || param instanceof RegExp || Buffer.isBuffer(param);
}
